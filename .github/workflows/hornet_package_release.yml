name: Build and Release Package

on:
  workflow_dispatch:  # Manual trigger
  push:
    branches:
      - main
    paths-ignore:
      - 'package.py'
      - 'client/ayon_nuke/version.py'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Increment version
        id: increment_version
        run: |
          # Create a Python script to handle version incrementing
          cat > increment_version.py << 'EOL'
          import re
          import os
          import sys

          # Read and extract current version from package.py
          with open('package.py', 'r') as f:
              package_content = f.read()

          # Use a pattern that specifically matches the version at the start of a line
          package_version_match = re.search(r'^version\s*=\s*"([^"]+)"', package_content, re.MULTILINE)
          if not package_version_match:
              print("Error: Could not find version in package.py")
              print("Content of package.py:")
              print(package_content)
              sys.exit(1)

          current_version = package_version_match.group(1)
          print(f"Current version: {current_version}")

          # Split at the last period to get base and suffix number
          parts = current_version.rsplit('.', 1)
          if len(parts) != 2:
              print("Error: Version format not as expected")
              sys.exit(1)

          version_base = parts[0]
          try:
              suffix_number = int(parts[1])
              new_suffix_number = suffix_number + 1
              new_version = f"{version_base}.{new_suffix_number}"
              print(f"New version: {new_version}")
          except ValueError:
              print(f"Error: Suffix '{parts[1]}' is not a number")
              sys.exit(1)

          # Update package.py - use regex with start-of-line anchor for safer replacement
          with open('package.py', 'r') as f:
              content = f.read()

          updated_content = re.sub(
              r'^version\s*=\s*"[^"]+"',
              f'version = "{new_version}"',
              content,
              flags=re.MULTILINE
          )

          with open('package.py', 'w') as f:
              f.write(updated_content)

          print(f"Updated package.py: {current_version} -> {new_version}")

          # Update client/ayon_nuke/version.py if it exists
          client_version_path = 'client/ayon_nuke/version.py'
          if os.path.exists(client_version_path):
              with open(client_version_path, 'r') as f:
                  client_content = f.read()

              # Determine which version pattern to use
              if '**version**' in client_content:
                  client_version_match = re.search(r'\*\*version\*\*\s*=\s*"([^"]+)"', client_content)
                  if client_version_match:
                      client_current_version = client_version_match.group(1)
                      updated_client_content = client_content.replace(
                          f'**version** = "{client_current_version}"',
                          f'**version** = "{new_version}"'
                      )
                      with open(client_version_path, 'w') as f:
                          f.write(updated_client_content)
                      print(f"Updated {client_version_path}: {client_current_version} -> {new_version}")
              else:
                  client_version_match = re.search(r'__version__\s*=\s*"([^"]+)"', client_content)
                  if client_version_match:
                      client_current_version = client_version_match.group(1)
                      updated_client_content = client_content.replace(
                          f'__version__ = "{client_current_version}"',
                          f'__version__ = "{new_version}"'
                      )
                      with open(client_version_path, 'w') as f:
                          f.write(updated_client_content)
                      print(f"Updated {client_version_path}: {client_current_version} -> {new_version}")

          # Create GitHub-friendly tag
          github_tag = new_version.replace('.', '_').replace('-', '_')
          print(f"GitHub tag: {github_tag}")

          # Output for GitHub Actions
          if 'GITHUB_OUTPUT' in os.environ:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"version={new_version}\n")
                  f.write(f"github_tag={github_tag}\n")
          EOL

          # Execute the Python script
          python increment_version.py

      - name: Create package
        run: |
          # Run create_package.py
          python create_package.py

          # Verify the package was created
          ls -la package/

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.increment_version.outputs.github_tag }}
          name: Release ${{ steps.increment_version.outputs.version }}
          draft: false
          prerelease: false
          files: |
            package/nuke-${{ steps.increment_version.outputs.version }}.zip
          generate_release_notes: true

      - name: Commit version changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.py client/ayon_nuke/version.py
          git commit -m "CI bump version to ${{ steps.increment_version.outputs.version }}"
          git push
